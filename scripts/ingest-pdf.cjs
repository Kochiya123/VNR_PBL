const fs = require("fs");
const path = require("path");

const PROJECT_ROOT = process.cwd();
const PDF_DIR = path.join(PROJECT_ROOT, "src", "reference", "pdfs");
const OUTPUT_DIR = path.join(PROJECT_ROOT, "src", "reference", "generated");

const loadPdfParse = () => {
  try {
    const mod = require("pdf-parse");
    
    // pdf-parse exports PDFParse class and other utilities
    // We need to use it as a function that takes a buffer
    if (typeof mod === "function") {
      return mod;
    }
    
    // If it's an object with PDFParse class, we need to use getText method
    if (mod.PDFParse) {
      return async (buffer) => {
        const parser = new mod.PDFParse({ data: buffer });
        const result = await parser.getText();
        return result;
      };
    }
    
    // Fallback: try default export
    if (mod.default && typeof mod.default === "function") {
      return mod.default;
    }
    
    throw new Error("Could not find pdf-parse function");
  } catch (error) {
    console.error("Error loading pdf-parse:", error.message);
    throw error;
  }
};

const slugify = (value) =>
  value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-zA-Z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .toLowerCase();

const sanitizeContent = (content) =>
  content
    .replace(/\u0000/g, "")
    .replace(/\r\n/g, "\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

const ensureDirectory = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

const readPdfFiles = () => {
  if (!fs.existsSync(PDF_DIR)) {
    console.warn(`PDF directory not found: ${PDF_DIR}`);
    return [];
  }

  return fs
    .readdirSync(PDF_DIR)
    .filter((file) => file.toLowerCase().endsWith(".pdf"))
    .map((file) => ({
      file,
      filePath: path.join(PDF_DIR, file),
    }));
};

const escapeTemplateLiteral = (text) => {
  return text
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\${/g, "\\${");
};

const extractPdfText = async (parser, filePath) => {
  const buffer = fs.readFileSync(filePath);
  
  try {
    // Try standard pdf-parse function call
    const result = await parser(buffer);
    
    // Handle different return types
    if (typeof result === "string") {
      return result;
    }
    if (result && typeof result === "object") {
      // Check for text property (standard pdf-parse output)
      if (result.text) {
        return result.text;
      }
      // Check if it's a result object with getText method
      if (typeof result.getText === "function") {
        const textResult = await result.getText();
        return typeof textResult === "string" ? textResult : textResult?.text || "";
      }
    }
    
    // If result is an object but no text found, try to stringify
    if (result && typeof result === "object") {
      return JSON.stringify(result);
    }
    
    return "";
  } catch (error) {
    console.error(`Error extracting text from ${path.basename(filePath)}:`, error.message);
    // Try alternative: use PDFParse class directly
    try {
      const mod = require("pdf-parse");
      if (mod.PDFParse) {
        const parserInstance = new mod.PDFParse({ data: buffer });
        const textResult = await parserInstance.getText({});
        return textResult?.text || textResult || "";
      }
    } catch (altError) {
      console.error("Alternative extraction also failed:", altError.message);
    }
    return "";
  }
};

const generateTypeScriptFile = (docId, title, source, content) => {
  const escapedTitle = escapeTemplateLiteral(title);
  const escapedSource = escapeTemplateLiteral(source);
  const escapedContent = escapeTemplateLiteral(content);
  
  return `import type { ReferenceDocument } from "../referenceTypes";

/**
 * Auto-generated from PDF: ${escapedSource}
 * Do not edit manually - this file is regenerated by the ingest script.
 */
export const document: ReferenceDocument = {
  id: "${docId}",
  title: "${escapedTitle}",
  source: "${escapedSource}",
  content: \`${escapedContent}\`,
};
`;
};

const updateGeneratedIndex = (documentFiles) => {
  const indexPath = path.join(OUTPUT_DIR, "index.ts");
  
  const imports = documentFiles
    .map((file, index) => {
      const moduleName = file.replace(".ts", "");
      return `import { document as doc${index} } from "./${moduleName}";`;
    })
    .join("\n");

  const exports = `export const generatedDocuments: ReferenceDocument[] = [\n${documentFiles
    .map((_, index) => `  doc${index},`)
    .join("\n")}\n];\n`;

  const content = `import type { ReferenceDocument } from "../referenceTypes";

/**
 * Auto-generated reference documents.
 *
 * Files in this directory are produced by the ingest scripts (for example,
 * when processing PDFs). Do not edit manually—changes will be overwritten.
 */
${imports}

${exports}`;

  fs.writeFileSync(indexPath, content, "utf8");
  console.log(`Updated ${path.relative(PROJECT_ROOT, indexPath)}`);
};

const main = async () => {
  try {
    const pdfParse = loadPdfParse();
    const pdfFiles = readPdfFiles();

    if (!pdfFiles.length) {
      console.warn("No PDF files found to ingest.");
      return;
    }

    console.log(`Found ${pdfFiles.length} PDF file(s). Processing...`);

    const generatedFiles = [];

    for (const { file, filePath } of pdfFiles) {
      console.log(`→ Extracting text from ${file} ...`);
      
      try {
        const rawContent = await extractPdfText(pdfParse, filePath);
        const content = sanitizeContent(rawContent);

        if (!content || content.length < 100) {
          console.warn(`Skipping ${file}: insufficient text content (${content.length} chars).`);
          continue;
        }

        const baseName = path.basename(file, path.extname(file));
        const docId = slugify(baseName) || `pdf-${Date.now()}`;
        const docFileName = `${docId}.ts`;
        const docFilePath = path.join(OUTPUT_DIR, docFileName);

        ensureDirectory(OUTPUT_DIR);

        const tsContent = generateTypeScriptFile(docId, baseName, `pdf:${file}`, content);
        fs.writeFileSync(docFilePath, tsContent, "utf8");

        generatedFiles.push(docFileName);
        console.log(
          `   ✓ Generated ${docFileName} (${content.length.toLocaleString()} characters)`,
        );
      } catch (error) {
        console.error(`   ✗ Failed to process ${file}:`, error.message);
      }
    }

    if (!generatedFiles.length) {
      console.warn("No documents extracted. Nothing to update.");
      return;
    }

    updateGeneratedIndex(generatedFiles);

    console.log(
      `\n✓ Successfully processed ${generatedFiles.length} PDF document(s).`,
    );
    console.log("  The chatbot will now reference these documents in its responses.");
  } catch (error) {
    console.error("Failed to ingest PDFs:", error);
    process.exitCode = 1;
  }
};

main();

